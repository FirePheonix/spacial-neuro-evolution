<!DOCTYPE html>

<head>
  <title>Spatiotemporal AV Navigator ‚Äî Spatial Visual Simulation</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      display: flex;
      font-family: 'Inter', sans-serif;
      background: #2a5;
    }

    #carCanvas {
      background: #2a5;
    }

    #sidePanel {
      width: 300px;
      min-width: 300px;
      background: #111827;
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #1e293b;
      overflow-y: auto;
      z-index: 20;
    }

    #sidePanel h2 {
      font-size: 13px;
      padding: 12px 14px 8px;
      color: #06b6d4;
      border-bottom: 1px solid #1e293b;
    }

    .section {
      padding: 10px 14px;
      border-bottom: 1px solid #1e293b;
    }

    .section h3 {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: #64748b;
      margin-bottom: 6px;
    }

    .metric-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
    }

    .metric-card {
      padding: 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, .04);
    }

    .metric-card label {
      font-size: 8px;
      color: #64748b;
      display: block;
    }

    .metric-card .val {
      font-size: 20px;
      font-weight: 800;
    }

    .metric-card.gw .val {
      color: #06b6d4;
    }

    .metric-card.gl .val {
      color: #8b5cf6;
    }

    .improve-bar {
      margin-top: 5px;
      text-align: center;
      padding: 5px;
      border-radius: 6px;
      background: rgba(34, 197, 94, .12);
      color: #22c55e;
      font-weight: 700;
      font-size: 11px;
    }

    .ctrl {
      margin-bottom: 6px;
    }

    .ctrl label {
      font-size: 10px;
      color: #94a3b8;
      display: flex;
      justify-content: space-between;
    }

    .ctrl label b {
      color: #06b6d4;
    }

    .ctrl input[type=range] {
      width: 100%;
      accent-color: #06b6d4;
      margin-top: 2px;
    }

    .btn-row {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }

    .btn {
      flex: 1;
      padding: 7px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-family: inherit;
      font-size: 10px;
      font-weight: 600;
    }

    .btn-cyan {
      background: #06b6d4;
      color: #000;
    }

    .btn-cyan:hover {
      background: #22d3ee;
    }

    .btn-ghost {
      background: transparent;
      border: 1px solid #334155;
      color: #94a3b8;
    }

    .btn-ghost:hover {
      border-color: #06b6d4;
      color: #06b6d4;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      margin-bottom: 2px;
    }

    .info-row .v {
      font-weight: 700;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      margin-bottom: 2px;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 2px;
    }

    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 5px;
      z-index: 30;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 10px;
      font-weight: 600;
      backdrop-filter: blur(6px);
    }

    .chip-time {
      background: rgba(6, 182, 212, .25);
      color: #06b6d4;
    }

    .chip-fps {
      background: rgba(255, 255, 255, .08);
      color: #64748b;
    }

    .chip-zone {
      background: rgba(139, 92, 246, .25);
      color: #8b5cf6;
    }

    /* ‚îÄ‚îÄ speed gauge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    #gauge {
      position: fixed;
      bottom: 14px;
      left: 14px;
      background: rgba(17, 24, 39, .9);
      backdrop-filter: blur(8px);
      border: 1px solid #1e293b;
      border-radius: 10px;
      padding: 12px 16px;
      color: #e2e8f0;
      min-width: 160px;
      z-index: 30;
    }

    .g-label {
      font-size: 8px;
      color: #64748b;
    }

    .g-speed {
      font-weight: 800;
    }

    .g-speed.gw {
      color: #06b6d4;
      font-size: 24px;
    }

    .g-speed.gl {
      color: #8b5cf6;
      font-size: 16px;
      margin-top: 3px;
    }

    .g-bar {
      height: 3px;
      border-radius: 2px;
      background: rgba(255, 255, 255, .08);
      margin-top: 3px;
    }

    .g-fill {
      height: 100%;
      border-radius: 2px;
      transition: width .2s;
    }

    /* minimap canvas */
    #miniMapCanvas {
      position: fixed;
      bottom: 14px;
      right: 314px;
      border: 2px solid #1e293b;
      border-radius: 8px;
      background: #1a3a25;
      z-index: 30;
    }

    /* ‚îÄ‚îÄ Setup overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    #setupOverlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 30px;
      background: rgba(0, 0, 0, .7);
    }

    #setupOverlay.active {
      display: flex;
    }

    #pickerCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    #setupBanner {
      background: rgba(17, 24, 39, .92);
      backdrop-filter: blur(12px);
      border: 1px solid #334155;
      padding: 20px 32px;
      border-radius: 14px;
      text-align: center;
      max-width: 420px;
      pointer-events: auto;
    }

    #setupBanner h2 {
      color: #06b6d4;
      font-size: 16px;
      margin-bottom: 6px;
    }

    #setupBanner p {
      color: #94a3b8;
      font-size: 12px;
      margin-bottom: 10px;
    }

    #setupBanner .step-badge {
      display: inline-block;
      padding: 4px 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 700;
    }

    .step-start {
      background: rgba(34, 197, 94, .2);
      color: #22c55e;
    }

    .step-target {
      background: rgba(239, 68, 68, .2);
      color: #ef4444;
    }

    .step-ready {
      background: rgba(6, 182, 212, .2);
      color: #06b6d4;
    }

    #launchBtn {
      margin-top: 12px;
      padding: 10px 30px;
      background: #06b6d4;
      border: none;
      border-radius: 8px;
      color: #000;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      display: none;
    }

    #launchBtn:hover {
      background: #22d3ee;
    }

    /* placed markers */
    .setup-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid #fff;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 101;
      animation: pulse 1.2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, .4);
      }

      50% {
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
      }
    }
  </style>
</head>

<body>

  <canvas id="carCanvas"></canvas>
  <canvas id="miniMapCanvas" width="200" height="200"></canvas>

  <!-- ROUTE PICKER OVERLAY -->
  <div id="setupOverlay" class="active">
    <canvas id="pickerCanvas"></canvas>
    <div id="setupBanner">
      <h2>üìç Set Route for Neuro-Evolution</h2>
      <p id="setupMsg">Click an <b>intersection</b> to set the <b style="color:#22c55e">START</b> point</p>
      <span class="step-badge step-start" id="setupBadge">üü¢ Step 1: Click a Start Intersection</span>
      <br>
      <button id="launchBtn" onclick="launchSim()">üöÄ Launch Simulation</button>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" style="display:none">
    <span class="chip chip-time" id="hud-time">08:00</span>
    <span class="chip chip-fps" id="hud-fps">60 FPS</span>
    <span class="chip chip-zone" id="hud-zone">‚Äî</span>
    <span class="chip" style="background:rgba(34,197,94,.25);color:#22c55e" id="hud-gen">Gen 1</span>
    <span class="chip" style="background:rgba(249,115,22,.2);color:#f97316" id="hud-alive">0 alive</span>
  </div>

  <!-- Speed gauge -->
  <div id="gauge">
    <div class="g-label">Spatial Optimal Speed</div>
    <div class="g-speed gw" id="g-gw">0 <small style="font-size:11px">mph</small></div>
    <div class="g-bar">
      <div class="g-fill" id="g-gw-f" style="width:0%;background:#06b6d4"></div>
    </div>
    <div class="g-label" style="margin-top:4px">Global Model Speed</div>
    <div class="g-speed gl" id="g-gl">0 <small style="font-size:9px">mph</small></div>
    <div class="g-bar">
      <div class="g-fill" id="g-gl-f" style="width:0%;background:#8b5cf6"></div>
    </div>
  </div>

  <!-- SIDE PANEL -->
  <div id="sidePanel">
    <h2>Spatiotemporal AV Navigator</h2>

    <div class="section">
      <h3>Model Comparison</h3>
      <div class="metric-grid">
        <div class="metric-card gw"><label>Spatial RMSE</label>
          <div class="val" id="m-gw-rmse">‚Äî</div>
        </div>
        <div class="metric-card gl"><label>Global RMSE</label>
          <div class="val" id="m-gl-rmse">‚Äî</div>
        </div>
        <div class="metric-card gw"><label>Spatial R¬≤</label>
          <div class="val" id="m-gw-r2">‚Äî</div>
        </div>
        <div class="metric-card gl"><label>Global R¬≤</label>
          <div class="val" id="m-gl-r2">‚Äî</div>
        </div>
      </div>
      <div class="improve-bar" id="improve">‚Äî</div>
    </div>

    <div class="section">
      <h3>Simulation Controls</h3>
      <div class="ctrl">
        <label>Time of Day <b id="tv">08:00</b></label>
        <input type="range" id="tSlider" min="0" max="24" step="0.25" value="8">
      </div>
      <div class="ctrl">
        <label>Sim Speed <b id="sv">1√ó</b></label>
        <input type="range" id="sSlider" min="0.5" max="5" step="0.5" value="1">
      </div>
      <div class="ctrl">
        <label>Cars <b id="cv">50</b></label>
        <input type="range" id="cSlider" min="1" max="100" step="1" value="50">
      </div>
      <div class="btn-row">
        <button class="btn btn-cyan" onclick="resetCars()">Reset</button>
        <button class="btn btn-ghost" onclick="togglePause()" id="pauseBtn">Pause</button>
      </div>
      <div class="btn-row">
        <button class="btn btn-cyan" onclick="save()">Save Brain</button>
        <button class="btn btn-ghost" onclick="discard()">Discard</button>
      </div>
    </div>

    <div class="section">
      <h3>Neuro-Evolution</h3>
      <div class="info-row"><span>Generation</span><span class="v" style="color:#22c55e" id="i-gen">1</span></div>
      <div class="info-row"><span>Alive</span><span class="v" style="color:#f97316" id="i-alive">0</span></div>
      <div class="info-row"><span>Best Fitness</span><span class="v" style="color:#06b6d4" id="i-fit">0</span></div>
      <div class="info-row"><span>Mutation Rate</span><span class="v" id="i-mut">10%</span></div>
    </div>

    <div class="section">
      <h3>Lead Car Status</h3>
      <div class="info-row"><span>Zone</span><span class="v" id="i-zone">‚Äî</span></div>
      <div class="info-row"><span>Spatial Speed Limit</span><span class="v" style="color:#06b6d4" id="i-gw">‚Äî</span>
      </div>
      <div class="info-row"><span>Global Speed</span><span class="v" style="color:#8b5cf6" id="i-gl">‚Äî</span></div>
      <div class="info-row"><span>Car Speed</span><span class="v" style="color:#22c55e" id="i-carspd">‚Äî</span></div>
      <div class="info-row"><span>Max Speed</span><span class="v" style="color:#f97316" id="i-maxspd">‚Äî</span></div>
      <div class="info-row"><span>Dist to Target</span><span class="v" style="color:#e2e8f0" id="i-dist">‚Äî</span></div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê virtual-world engine scripts ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <script src="/static/world/js/world.js"></script>
  <script src="/static/world/js/viewport.js"></script>
  <script src="/static/world/js/markings/marking.js"></script>
  <script src="/static/world/js/markings/stop.js"></script>
  <script src="/static/world/js/markings/start.js"></script>
  <script src="/static/world/js/markings/crossing.js"></script>
  <script src="/static/world/js/markings/parking.js"></script>
  <script src="/static/world/js/markings/light.js"></script>
  <script src="/static/world/js/markings/target.js"></script>
  <script src="/static/world/js/markings/yield.js"></script>
  <script src="/static/world/js/editors/markingEditor.js"></script>
  <script src="/static/world/js/editors/graphEditor.js"></script>
  <script src="/static/world/js/editors/crossingEditor.js"></script>
  <script src="/static/world/js/editors/stopEditor.js"></script>
  <script src="/static/world/js/editors/startEditor.js"></script>
  <script src="/static/world/js/editors/parkingEditor.js"></script>
  <script src="/static/world/js/editors/targetEditor.js"></script>
  <script src="/static/world/js/editors/yieldEditor.js"></script>
  <script src="/static/world/js/items/tree.js"></script>
  <script src="/static/world/js/items/building.js"></script>
  <script src="/static/world/js/math/utils.js"></script>
  <script src="/static/world/js/math/graph.js"></script>
  <script src="/static/world/js/math/osm.js"></script>
  <script src="/static/world/js/primitives/point.js"></script>
  <script src="/static/world/js/primitives/segment.js"></script>
  <script src="/static/world/js/primitives/polygon.js"></script>
  <script src="/static/world/js/primitives/envelope.js"></script>

  <script src="/static/visualizer.js"></script>
  <script src="/static/network.js"></script>
  <script src="/static/sensor.js"></script>
  <script src="/static/utils.js"></script>
  <script src="/static/controls.js"></script>
  <script src="/static/car.js"></script>
  <script src="/static/miniMap.js"></script>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê load saved world & run ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <script src="/static/world/saves/big.world"></script>
  <script>
    // ‚îÄ‚îÄ‚îÄ Canvas Setup ‚îÄ‚îÄ‚îÄ
    const carCanvas = document.getElementById("carCanvas");
    carCanvas.width = window.innerWidth - 300;
    carCanvas.height = window.innerHeight;
    window.addEventListener("resize", () => {
      carCanvas.width = window.innerWidth - 300;
      carCanvas.height = window.innerHeight;
    });

    const carCtx = carCanvas.getContext("2d");

    // ‚îÄ‚îÄ‚îÄ Viewport (zoom + pan from virtual-world) ‚îÄ‚îÄ‚îÄ
    const viewport = new Viewport(carCanvas, world.zoom, world.offset);

    // ‚îÄ‚îÄ‚îÄ ROUTE PICKER (Interactive Map) ‚îÄ‚îÄ‚îÄ
    let setupStep = 0;
    let startPoint = null;
    let startDir = new Point(0, -1);
    let target = null;
    let simStarted = false;
    let worldNodes = []; // Data from backend
    let zoneMeta = {};

    const pickerCanvas = document.getElementById("pickerCanvas");
    const pickerCtx = pickerCanvas.getContext("2d");



    // View State (Camera)
    let view = { x: 0, y: 0, zoom: 0.3 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let viewStart = { x: 0, y: 0 };
    let hoverIdx = -1;

    async function initPicker() {
      pickerCanvas.width = window.innerWidth;
      pickerCanvas.height = window.innerHeight;

      // Fetch zone data
      try {
        const r = await fetch("/api/world");
        const data = await r.json();
        worldNodes = data.nodes;
        zoneMeta = data.zone_meta;
      } catch (e) { console.warn("Failed to load world zones", e); }

      // Auto-center on data
      const pts = world.graph.points;
      if (pts.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const p of pts) {
          if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        view.x = cx;
        view.y = cy;
        // fit zoom
        const w = maxX - minX || 1000;
        const h = maxY - minY || 1000;
        view.zoom = Math.min(pickerCanvas.width / w, pickerCanvas.height / h) * 0.8;
      }

      drawPicker();
    }

    function screenToWorld(sx, sy) {
      return {
        x: (sx - pickerCanvas.width / 2) / view.zoom + view.x,
        y: (sy - pickerCanvas.height / 2) / view.zoom + view.y
      };
    }

    function drawPicker() {
      const ctx = pickerCtx;

      // Background
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, pickerCanvas.width, pickerCanvas.height);

      ctx.save();
      // Apply Camera Transform: Center -> Scale -> Translate
      ctx.translate(pickerCanvas.width / 2, pickerCanvas.height / 2);
      ctx.scale(view.zoom, view.zoom);
      ctx.translate(-view.x, -view.y);

      // ‚îÄ‚îÄ‚îÄ Draw ZONES (Translucent Circles) ‚îÄ‚îÄ‚îÄ
      if (worldNodes.length > 0) {
        for (const n of worldNodes) {
          const meta = zoneMeta[n.zone];
          if (meta) {
            ctx.beginPath();
            // Large soft circle approx 300px radius (coverage)
            ctx.arc(n.x, n.y, 180, 0, Math.PI * 2);
            ctx.fillStyle = meta.color + "33"; // 20% opacity hex
            ctx.fill();
          }
        }
      }

      // Draw Roads
      ctx.strokeStyle = '#334155'; ctx.lineWidth = 40; ctx.lineCap = 'round';
      for (const seg of world.graph.segments) {
        ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke();
      }
      // Dashed Line
      ctx.setLineDash([20, 20]); ctx.strokeStyle = 'rgba(255,255,255,.2)'; ctx.lineWidth = 3;
      for (const seg of world.graph.segments) {
        ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke();
      }
      ctx.setLineDash([]);

      // Draw Intersections
      const pts = world.graph.points;
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const isStart = startPoint && p === startPoint;
        const isTarget = target && p === target;
        const isHover = (i === hoverIdx);

        let rad = 18;
        if (isHover) rad = 25;
        if (isStart || isTarget) rad = 30;

        ctx.beginPath();
        ctx.arc(p.x, p.y, rad, 0, Math.PI * 2);

        if (isStart) {
          ctx.fillStyle = '#22c55e'; ctx.shadowColor = '#22c55e'; ctx.shadowBlur = 30;
        } else if (isTarget) {
          ctx.fillStyle = '#ef4444'; ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 30;
        } else if (isHover) {
          ctx.fillStyle = '#06b6d4'; ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = 20;
        } else {
          ctx.fillStyle = '#94a3b8'; ctx.shadowBlur = 0;
        }
        ctx.fill();
        ctx.shadowBlur = 0;

        // Ring
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke();

        // Labels
        if (isStart || isTarget) {
          ctx.save();
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 36px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4;
          ctx.fillText(isStart ? 'START' : 'TARGET', p.x, p.y - 45);
          ctx.restore();
        }
      }
      ctx.restore();

      // UI Overlay
      ctx.font = 'bold 16px Inter, sans-serif';
      ctx.fillStyle = 'rgba(148, 163, 184, 0.8)';
      ctx.textAlign = 'center';
      ctx.fillText('üñ±Ô∏è Left Drag to Pan ‚Ä¢ üìú Scroll to Zoom ‚Ä¢ Select Start & Target', pickerCanvas.width / 2, 35);

      // Legend
      if (zoneMeta && Object.keys(zoneMeta).length > 0) {
        let lx = pickerCanvas.width - 140;
        let ly = pickerCanvas.height - 150;
        ctx.textAlign = 'left';
        ctx.font = 'bold 12px Inter, sans-serif';

        // Legend Box
        ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
        ctx.beginPath(); ctx.roundRect(lx - 20, ly - 20, 140, 160, 10); ctx.fill();
        ctx.strokeStyle = '#334155'; ctx.lineWidth = 1; ctx.stroke();

        ctx.fillStyle = '#94a3b8'; ctx.fillText("ZONES", lx, ly - 5);

        Object.entries(zoneMeta).forEach(([name, meta]) => {
          ly += 20;
          ctx.beginPath(); ctx.arc(lx, ly, 6, 0, Math.PI * 2);
          ctx.fillStyle = meta.color; ctx.fill();
          ctx.fillStyle = '#cbd5e1';
          ctx.fillText(name.charAt(0).toUpperCase() + name.slice(1), lx + 15, ly + 4);
        });
      }
    }

    // ‚îÄ‚îÄ‚îÄ Interaction Handlers ‚îÄ‚îÄ‚îÄ
    pickerCanvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      viewStart = { x: view.x, y: view.y };
      pickerCanvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      pickerCanvas.style.cursor = 'default';
    });

    pickerCanvas.addEventListener('mousemove', e => {
      if (simStarted) return;
      const rect = pickerCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Panning
      if (isDragging) {
        const dx = (e.clientX - dragStart.x) / view.zoom;
        const dy = (e.clientY - dragStart.y) / view.zoom;
        view.x = viewStart.x - dx;
        view.y = viewStart.y - dy;
        drawPicker();
        return;
      }

      // Hover Check
      const worldPt = screenToWorld(mx, my);
      const pts = world.graph.points;
      hoverIdx = -1;
      let bestD = 40 / view.zoom; // Adjust hit area by zoom? Or keep fixed in world units?
      // Actually fixed in screen pixels is better for UX, but world units is easier.
      // Let's use world units ~50
      bestD = 60;

      for (let i = 0; i < pts.length; i++) {
        const d = Math.hypot(pts[i].x - worldPt.x, pts[i].y - worldPt.y);
        if (d < bestD) { bestD = d; hoverIdx = i; }
      }
      pickerCanvas.style.cursor = hoverIdx >= 0 ? 'pointer' : 'default';
      drawPicker();
    });

    pickerCanvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomSensitivity = 0.001;
      const newZoom = view.zoom - e.deltaY * zoomSensitivity * view.zoom;

      // Zoom towards mouse pointer
      const rect = pickerCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const worldBefore = screenToWorld(mx, my);

      view.zoom = Math.max(0.05, Math.min(5, newZoom));

      const worldAfter = screenToWorld(mx, my);

      // Adjust view.x/y to keep world point under mouse
      view.x += (worldBefore.x - worldAfter.x);
      view.y += (worldBefore.y - worldAfter.y);

      drawPicker();
    });

    pickerCanvas.addEventListener('click', e => {
      if (simStarted || hoverIdx < 0) return;
      // Filter out drag-clicks
      const d = Math.hypot(e.clientX - dragStart.x, e.clientY - dragStart.y);
      if (d > 5) return;

      const clicked = world.graph.points[hoverIdx];

      if (setupStep === 0) {
        startPoint = clicked;
        setupStep = 1;
        document.getElementById('setupMsg').innerHTML = 'Start set! Now click a <b style="color:#ef4444">TARGET</b>';
        document.getElementById('setupBadge').className = 'step-badge step-target';
        document.getElementById('setupBadge').textContent = 'üî¥ Step 2: Pick Target';
      } else if (setupStep === 1 && clicked !== startPoint) {
        target = clicked;
        setupStep = 2;
        document.getElementById('setupMsg').innerHTML = 'Route locked! Launch to evolve.';
        document.getElementById('setupBadge').className = 'step-badge step-ready';
        document.getElementById('setupBadge').textContent = '‚úÖ Ready to Launch';
        document.getElementById('launchBtn').style.display = 'inline-block';
      }
      drawPicker();
    });

    window.addEventListener('resize', () => { initPicker(); });
    // Init logic runs once
    setTimeout(() => { initPicker(); }, 100);

    function launchSim() {
      if (!startPoint || !target) return;
      simStarted = true;
      document.getElementById("setupOverlay").classList.remove("active");
      document.getElementById("setupOverlay").style.display = 'none';
      document.getElementById("hud").style.display = 'flex';

      // Direction from start (as crow flies)
      const dx = target.x - startPoint.x;
      const dy = target.y - startPoint.y;

      // AUTO-ALIGNMENT: Find the road segment connected to Start that points best towards Target
      const targetVec = new Point(dx, dy);
      let bestRoadDir = targetVec; // fallback
      let maxDot = -2; // cos(theta) is between -1 and 1

      // Normalize target direction for comparison
      const tMag = magnitude(targetVec) || 1;
      const tNorm = scale(targetVec, 1 / tMag);

      for (const seg of world.graph.segments) {
        let roadVec = null;
        if (seg.p1 === startPoint) { roadVec = subtract(seg.p2, seg.p1); }
        else if (seg.p2 === startPoint) { roadVec = subtract(seg.p1, seg.p2); }

        if (roadVec) {
          const rMag = magnitude(roadVec) || 1;
          const rNorm = scale(roadVec, 1 / rMag);

          // Dot product: how much does road align with target?
          const dot = rNorm.x * tNorm.x + rNorm.y * tNorm.y;

          if (dot > maxDot) {
            maxDot = dot;
            bestRoadDir = roadVec;
          }
        }
      }

      const len = magnitude(bestRoadDir) || 1;
      startDir = scale(bestRoadDir, 1 / len);

      // Add markings to the world so they render on the road map
      world.markings.push(new Start(startPoint, startDir, 40, 40));
      world.markings.push(new Target(target, startDir, 40, 40));

      // Generate cars and init brains
      N = parseInt(document.getElementById("cSlider").value);
      cars = generateCars(N);
      bestCar = cars[0];

      // Traffic lights and zombie cars removed ‚Äî they were non-functional

      if (localStorage.getItem("bestBrain")) {
        const storedBrain = JSON.parse(localStorage.getItem("bestBrain"));
        // Check if topology matches (Sensor Ray Count + GPS inputs)
        if (storedBrain.levels && storedBrain.levels[0].inputs.length === cars[0].brain.levels[0].inputs.length) {
          for (let i = 0; i < cars.length; i++) {
            cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
            if (i !== 0) NeuralNetwork.mutate(cars[i].brain, 0.1);
          }
        } else {
          console.warn("Saved brain topology mismatch. Discarding old brain.");
          localStorage.removeItem("bestBrain");
          // alert("Brain topology updated! Starting fresh evolution.");
        }
      }
    }

    let N = 50;
    let cars = [];
    let bestCar = null;
    let generation = 1;
    const MUTATION_RATE = 0.1;

    const roadBorders = world.roadBorders.map((s) => [s.p1, s.p2]);

    const miniMapCanvas = document.getElementById("miniMapCanvas");
    const miniMap = new MiniMap(miniMapCanvas, world.graph, 200);

    let simHour = 8, simSpeed = 1, paused = false;
    let gwPred = { gw_speed: 0, global_speed: 0, zone: "" };
    let metrics = {};
    let frameCount = 0, lastFpsT = performance.now(), fps = 60;

    async function loadMetrics() {
      try {
        const r = await fetch("/api/metrics");
        metrics = await r.json();
        document.getElementById("m-gw-rmse").textContent = metrics.gwlearn.rmse;
        document.getElementById("m-gl-rmse").textContent = metrics.global.rmse;
        document.getElementById("m-gw-r2").textContent = metrics.gwlearn.r2;
        document.getElementById("m-gl-r2").textContent = metrics.global.r2;
        const imp = ((metrics.global.rmse - metrics.gwlearn.rmse) / metrics.global.rmse * 100).toFixed(1);
        document.getElementById("improve").textContent = `üöÄ GWLearn is ${imp}% more accurate`;
      } catch (e) { console.warn("metrics fetch failed", e); }
    }

    async function fetchPrediction() {
      if (!bestCar) return;
      try {
        const r = await fetch("/api/predict", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ x: bestCar.x, y: bestCar.y, hour: simHour })
        });
        gwPred = await r.json();
      } catch (e) { }
    }

    function generateCars(N) {
      /* Start point handled globally above */
      const startAngle = -angle(startDir) - Math.PI / 2;

      const cars = [];
      for (let i = 1; i <= N; i++) {
        cars.push(new Car(startPoint.x, startPoint.y, 30, 50, "AI", startAngle));
      }
      return cars;
    }

    function resetCars() {
      N = parseInt(document.getElementById("cSlider").value);
      cars = generateCars(N);
      bestCar = cars[0];
      if (localStorage.getItem("bestBrain")) {
        for (let i = 0; i < cars.length; i++) {
          cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
          if (i != 0) NeuralNetwork.mutate(cars[i].brain, 0.1);
        }
      }
    }

    function save() {
      localStorage.setItem("bestBrain", JSON.stringify(bestCar.brain));
    }

    function discard() {
      localStorage.removeItem("bestBrain");
    }

    function togglePause() {
      paused = !paused;
      document.getElementById("pauseBtn").textContent = paused ? "‚ñ∂ Play" : "‚è∏ Pause";
    }

    // ‚îÄ‚îÄ‚îÄ NEURO-EVOLUTION: auto-learn on crash ‚îÄ‚îÄ‚îÄ
    function checkEvolution() {
      const alive = cars.filter(c => !c.damaged && !c.finished).length;
      const finished = cars.filter(c => c.finished).length;

      // Update HUD
      document.getElementById("hud-alive").textContent = `üöó ${alive} alive`;
      document.getElementById("hud-gen").textContent = `üß¨ Gen ${generation}`;
      document.getElementById("i-gen").textContent = generation;
      document.getElementById("i-alive").textContent = `${alive} / ${cars.length}`;
      document.getElementById("i-fit").textContent = Math.round(bestCar.fittness);

      // ALL CARS DEAD OR FINISHED ‚Üí EVOLVE!
      if (alive === 0 && cars.length > 0) {
        // Save best brain
        localStorage.setItem("bestBrain", JSON.stringify(bestCar.brain));
        console.log(`üß¨ Gen ${generation} complete | Best fitness: ${Math.round(bestCar.fittness)} | Evolving...`);

        // Next generation
        generation++;

        // Reset cars with mutated copies of the winner
        N = parseInt(document.getElementById("cSlider").value);
        cars = generateCars(N);
        for (let i = 0; i < cars.length; i++) {
          cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
          if (i !== 0) {
            NeuralNetwork.mutate(cars[i].brain, MUTATION_RATE);
          }
        }
        bestCar = cars[0];
      }
    }

    // ‚îÄ‚îÄ‚îÄ UI Updates ‚îÄ‚îÄ‚îÄ
    function updateUI() {
      const hh = Math.floor(simHour), mm = Math.round((simHour - hh) * 60);
      const ts = `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
      document.getElementById("hud-time").textContent = `üïê ${ts}`;
      document.getElementById("hud-fps").textContent = `${fps} FPS`;
      document.getElementById("hud-zone").textContent = `Zone: ${gwPred.zone || "‚Äî"}`;
      document.getElementById("tv").textContent = ts;

      document.getElementById("g-gw").innerHTML = `${Math.round(gwPred.gw_speed || 0)} <small style="font-size:11px">mph</small>`;
      document.getElementById("g-gl").innerHTML = `${Math.round(gwPred.global_speed || 0)} <small style="font-size:9px">mph</small>`;
      document.getElementById("g-gw-f").style.width = `${Math.min(100, (gwPred.gw_speed || 0) / 60 * 100)}%`;
      document.getElementById("g-gl-f").style.width = `${Math.min(100, (gwPred.global_speed || 0) / 60 * 100)}%`;

      document.getElementById("i-zone").textContent = gwPred.zone || "‚Äî";
      document.getElementById("i-gw").textContent = `${Math.round(gwPred.gw_speed || 0)} mph`;
      document.getElementById("i-gl").textContent = `${Math.round(gwPred.global_speed || 0)} mph`;

      // Car speed, max speed, and distance to target
      if (bestCar) {
        const carSpeedMph = Math.round(bestCar.speed * 10);
        const maxSpeedMph = Math.round(bestCar.maxSpeed * 10);
        document.getElementById("i-carspd").textContent = `${carSpeedMph} mph`;
        document.getElementById("i-maxspd").textContent = `${maxSpeedMph} mph`;
        if (target) {
          const dist = Math.round(Math.hypot(bestCar.x - target.x, bestCar.y - target.y));
          document.getElementById("i-dist").textContent = `${dist} units`;
        }
      }
    }

    // ‚îÄ‚îÄ‚îÄ Prediction timer ‚îÄ‚îÄ‚îÄ
    let predTimer = 0;

    // ‚îÄ‚îÄ‚îÄ MAIN ANIMATION LOOP ‚îÄ‚îÄ‚îÄ
    function animate(time) {
      requestAnimationFrame(animate);

      // FPS
      frameCount++;
      if (performance.now() - lastFpsT > 1000) { fps = frameCount; frameCount = 0; lastFpsT = performance.now(); }

      if (!paused && simStarted && bestCar) {
        // advance time
        simHour += 0.001 * simSpeed;
        if (simHour >= 24) simHour -= 24;
        document.getElementById("tSlider").value = simHour;

        // update cars
        // APPLY GWLEARN SPEED LIMITS:
        const speedLimit = (gwPred.gw_speed && gwPred.gw_speed > 5) ? (gwPred.gw_speed / 10) : 3;

        for (let i = 0; i < cars.length; i++) {
          cars[i].maxSpeed = speedLimit; // Use GWLearn speed limit!
          cars[i].update(roadBorders, [], target);
        }
        bestCar = cars.find(
          c => c.fittness == Math.max(...cars.map(c => c.fittness))
        );

        // Check if all cars crashed ‚Üí auto-evolve
        checkEvolution();

        // GWLearn predictions
        predTimer++;
        if (predTimer > 60) {
          predTimer = 0;
          fetchPrediction();
        }
      }

      world.cars = cars;
      world.bestCar = bestCar;

      // follow best car (or center of map during setup)
      if (bestCar) {
        viewport.offset.x = -bestCar.x;
        viewport.offset.y = -bestCar.y;
      }

      viewport.reset();
      const viewPoint = scale(viewport.getOffset(), -1);
      world.draw(carCtx, viewPoint, false);

      for (let i = 0; i < cars.length; i++) {
        const isBest = cars[i] === bestCar;
        cars[i].draw(carCtx, isBest);
      }

      // Draw target beacon (pulsing circle)
      if (target && simStarted) {
        carCtx.save();
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
        carCtx.beginPath();
        carCtx.arc(target.x, target.y, 20 + pulse * 10, 0, Math.PI * 2);
        carCtx.fillStyle = `rgba(239, 68, 68, ${0.15 + pulse * 0.15})`;
        carCtx.fill();
        carCtx.beginPath();
        carCtx.arc(target.x, target.y, 8, 0, Math.PI * 2);
        carCtx.fillStyle = '#ef4444';
        carCtx.fill();
        carCtx.strokeStyle = '#fff';
        carCtx.lineWidth = 2;
        carCtx.stroke();
        carCtx.restore();
      }

      // minimap
      miniMap.update(viewPoint);

      if (simStarted) updateUI();
    }

    // ‚îÄ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ
    document.getElementById("tSlider").addEventListener("input", e => { simHour = parseFloat(e.target.value); });
    document.getElementById("sSlider").addEventListener("input", e => {
      simSpeed = parseFloat(e.target.value);
      document.getElementById("sv").textContent = simSpeed + "√ó";
    });
    document.getElementById("cSlider").addEventListener("input", e => {
      document.getElementById("cv").textContent = e.target.value;
      N = parseInt(e.target.value);
      resetCars();
    });

    // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ
    loadMetrics();
    animate();
  </script>
</body>

</html>